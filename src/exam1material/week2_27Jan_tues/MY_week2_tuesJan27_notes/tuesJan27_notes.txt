Homework 1 due tonight
    last problem:

        You know the thief was either Agatha, Ferdinand, or Carl.
            (some statements)
        You later learn that Carl and Ferdinand were not both telling the truth.

    What are the possible cases?
    How to check if a possible case works?


I'll post Homework 2 after class (due Tues Feb 3)

/////////////////////

Today:

- review implies operator
- evaluating logical statements
- compound truth tables
- using Logika
- parse trees
- begin propositional logic

//////////////////////////////////////////


Review: IMPLIES operator →

"If it is snowing, then I will bring a coat"

p: It is snowing
q: I will bring a coat

p → q

When is this true? When is this false?


p q  #  p → q
--------------
T T  #    
T F  #    
F T  #    
F F  #    

//////////////////////////////////////

Evaluating logical statements.

Basic operations:

∧ - 
∨ - 
¬ - 
→ - 

////////////////////////////////////////

Consider ¬p ∨ q → p ∧ ¬q

--> what operation do we do first?




Add () to show the order of operations.





Evaluate the above statement using these
variable assignments:

p is T
q is F
r is F





////////////////////////////////////////////////

Order of operations
    ¬ evaluates right to left
        ¬¬p is equivalent to....


    ∧ and ∨ evaluate left to right
        p ∧ q ∧ r is equivalent to....
        p ∨ q ∨ r is equivalent to....


    → evaluates right to left
        p → q → r is equivalent to....





//////////////////////////////////////////

Top-level operator (what happens LAST?)


¬p ∨ q ∧ r


top-level? 


How is this similar to a circuit? 



///////////////////////////////

p ∧ q ∨ r ∧ p

rewrite with ():


top-level operator? 



//////////////////////////////

p ∧ q ∧ r ∧ s

rewrite with ():


top-level operator?  


////////////////////////////////////////////////////

parse trees

The variables will always be at the bottom.
The structure already shows the precedence, so parentheses aren't needed.
Implies always goes at the top. 
Not operator always applied first.

--> what are they?
A hierarchical, ordered, rooted tree representation of the syntactic structure of an input string.

--> draw one for (p ∧ q) → ¬r

--> how do they relate to programming?
Compilers use recursive desent to figure out the code in a tree-like structure.

--> what is the "top-level operator" here?
The implies! *always the leftmost*




--> draw one for p ∨ q ∧ r → ¬p → ¬q ∨ s





--> expression trees
Are hierarchical data structures that represent mathematical expressions as a tree.



////////////////////////////////////////////////////

In-class practice quiz

////////////////////////////////////////////////////

Listing all truth assignments for a logical statement.



If we have 2 variables, how many possible truth assignments?

    p, q

4
T T
T F
F T
F F





If we have 3 variables, how many possible truth assignments?

    p, q, r

8
All 4 previously + the same outcomes for R


If we have n variables, how many possible truth assignments?
2^n





////////////////////////////////////////////////////

Classifying logical statements based on truth assignments.



Contingent, contradictory, tautology



contingent: mix of true and false output

    Example? p ∨ q



contradictory: always false

    Example? ¬p ∨ p


tautology: always true

    Example? ¬p V p
    

///////////////////////////////////////////

∧ ∨ ¬ →

///////////////////////////////////////////

Compound truth tables.


Write a truth table for:

(p ∧ r) → (r ∨ ¬q)


-----------------------------
p q r  #  (p ∧ r) → (r ∨ ¬q)
-----------------------------
T T T #      T    T     T  F
T T F #      F    T     F  F
T F T #      T    T     T  T
T F F #      F    T     T  T
F T T #      F    T     T  F
T F T #      F    T     F  F
F F T #      F    T     T  T
F F F #      F    T     T  T
-----------------------------

Tautology



--> top-level operator?

--> need to evaluate statement on ALL possible truth assignments

--> how many truth assignments are there?

--> how would we classify this truth table?


/////////////////////////////////////////

complete truth table in truth.logika

--> what to type for different operators


AND: &
OR: |
NOT: !
IMPLIES: ->:

alignment matters!

--> order of operations in Logika

//////////////////////////////////////
Complete tautology.logika

//////////////////////////////////////

Propositional logic.


- a set of propositional atoms (statements that can be T/F)
    --> these will be our boolean variables in logic statements
    --> must be as simple as possible; ex: p: I go to class (not the negation)



- connected by logical operators



- join together to make new propositions (logical sentences)
    that can be true or false



////////////////////////////////////////

Which ones are propositions?

Today is Thursday. yes


What time is it? no


x == 2 yes


Pigs can fly. yes


Drive carefully. no


y <= 4 yes



////////////////////////////////////////

Suppose we have these propositional atoms:

    p: It is below freezing.

    q: It is snowing.

    r: y <= 4

    s: x == 2


How would we express these as English sentences?

    ¬p: It is not below freezing.


    p ∧ q: It is below freezing and it's snowing.


    p → q: If it is below freezing, then it is snowing.
        p = F
        q = T 
        outputs true


    ¬p → ¬q: If it is not below freezing, then it is not snowing.
        p = F
        q = T 
        outputs false

    r ∨ s: y <= 4 || x == 2

    ¬r: y > 4

////////////////////////

Next time:

- A bit more with translations
- Equivalent propositions
- DeMorgan's laws
- Equivalent if-statements
- Negating if-statements
- Proving equivalence with truth tables
- Satisfiability